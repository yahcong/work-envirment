linux shell的here document用法(cat << EOF):

什么是Here Document
Here Document 是在Linux Shell 中的一种特殊的重定向方式，它的基本的形式如下

cmd << delimiter
Here Document Content
delimiter

它的作用就是将两个 delimiter 之间的内容(Here Document Content 部分) 传递给cmd 作为输入参数。
如:在shell 文件中使用，例如下面的here.sh 文件

cat << EOF > output.sh
echo "hello"
echo "world"
EOF

使用 sh here.sh 运行这个脚本文件，会得到output.sh 这个新文件，里面的内容如下
echo "hello"
echo "world"

这里要注意几点
EOF 只是一个标识而已，可以替换成任意的合法字符
作为结尾的delimiter一定要顶格写，前面不能有任何字符
作为结尾的delimiter后面也不能有任何的字符（包括空格）
作为起始的delimiter前后的空格会被省略掉
-----
環境變量：

set命令作用主要是显示系统中已经存在的shell变量，以及设置shell变量的新变量值。使用set更改shell特性时，符号"+"和"-"的作用分别是打开和关闭指定的模式。set命令不能够定义新的shell变量。如果要定义新的变量，可以使用declare命令以变量名=值的格式进行定义即可。
env命令用于显示系统中已存在的环境变量，以及在定义的环境中执行指令。该命令只使用"-"作为参数选项时，隐藏了选项"-i"的功能。若没有设置任何选项和参数时，则直接显示当前的环境变量。
例：
使用declare命令定义一个新的环境变量"mylove"，并且将其值设置为"Visual C++"，
输入如下命令： declare mylove='Visual C++' #定义新环境变量 
再使用set命令将新定义的变量输出为环境变量，
输入如下命令： set -a mylove #设置为环境变量 执行该命令后，将会新添加对应的环境变量。
用户可以使用env命令和grep命令分别显示和搜索环境变量"mylove"，
输入命令如下： env | grep mylove

-----
推荐使用类似如下函数，将错误信息和其他状态信息一起打印出来。

err() {
    echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@" >&2
}

if ! do_something; then
    err "Unable to do_something"
    exit "${E_DID_NOTHING}"
fi

比如kdump的log函數
log()
{
    local level="$1"
    shift
    echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] $level $*" >> "${K_LOG_FILE}"
    if [[ $level == "ERROR" ]]; then
        echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] $level $*" >&2
    else
        echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] $level $*"
    fi
}

log_error()
{
    log "ERROR" "$@"
    ready_to_exit 1
    exit 1
}

$@ 是传给脚本的所有参数的列表
>&2  即 1>&2 也就是把结果输出到和标准错误一样
$0 是脚本本身的名字
$1 是传递给该shell脚本的第一个参数

$* 是以一个单字符串显示所有向脚本传递的参数，与位置变量不同，参数可超过9个

$*and $@不同点：
只有在双引号中体现出来。假设在脚本运行时写了三个参数（分别存储在112 3）则"3）则
"*" 等价于 “112 3"（传递了一个参数）；
而“3"（传递了一个参数）；而“@" 等价于 "1""1""2" "$3"（传递了三个参数）

-----
shell中各种括号的作用()、(())、[]、[[]]、{}

一、小括号，圆括号（）
1、单小括号 ()
	① 命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。
	② 命令替换。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。
    ③ 用于初始化数组。如：array=(a b c d)
2、双小括号 (( ))
	常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 
	只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i<5;i++)), 如果不使用双括号, 则为for i in `seq 0 4`或者for i in {0..4}。
	再如可以直接使用if (($i<5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。
二、中括号，方括号[]
1、单中括号 []
	① bash 的内部命令，[]和test命令是等同的。
	② Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，
		整数比较只能使用-eq，-gt这种形式。
		无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，
		如比较"ab"和"bc"：[ ab \< bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。
	③　字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。
2、双中括号[[ ]]
	① [[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。
	② 支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。
		字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，
		比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。
    ③ 使用[[ ... ]]条件判断结构，而不是[ ... ]，能够防止脚本中的许多逻辑错误。
		比如，&&、||、<和> 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。
		比如可以直接使用if [[ $a != 1 && $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] && [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。
    ④ bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。
三、大括号、花括号 {}
1、常规用法
	① 大括号拓展。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。
		第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。
		第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt
	② 代码块，又被称为内部组，这个结构事实上创建了一个匿名函数 。
		与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。
		括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。
2、几种特殊的替换结构
	${var:-string},${var:+string},${var:=string},${var:?string}
	① ${var:-string}和${var:=string}:若变量var为空，则用在命令行中用string来替换${var:-string}，
		否则变量var不为空时，则用变量var的值来替换${var:-string}；
		对于${var:=string}的替换规则和${var:-string}是一样的，所不同之处是${var:=string}若var为空时，用string替换${var:=string}的同时，把string赋给变量var： 
		${var:=string}很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。
    ② ${var:+string}的替换规则和上面的相反，即只有当var不是空的时候才替换成string，
		若var为空时则不替换或者说是替换成变量 var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的) 
    ③ ${var:?string}替换规则为：若变量var不为空，则用变量var的值来替换${var:?string}；
		若变量var为空，则把string输出到标准错误中，并从脚本中退出。我们可利用此特性来检查是否设置了变量的值。
3、四种模式匹配替换结构
	模式匹配记忆方法：
	# 是去掉左边(在键盘上#在$之左边)
	% 是去掉右边(在键盘上%在$之右边)
	#和%中的单一符号是最小匹配，两个相同符号是最大匹配。
	${var%pattern},${var%%pattern},${var#pattern},${var##pattern}
	     第一种模式：${variable%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最短的匹配模式
	     第二种模式： ${variable%%pattern}，这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
		 第三种模式：${variable#pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern开始，如果是，就从命令行把variable中的内容去掉左边最短的匹配模式
	     第四种模式： ${variable##pattern} 这种模式时，shell在variable中查找，看它是否一给的模式pattern结尾，如果是，就从命令行把variable中的内容去掉右边最长的匹配模式
	这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。
		结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[...]表示匹配中括号里面的字符，[!...]表示不匹配中括号里面的字符.
4、字符串提取和替换
	${var:num},${var:num1:num2},${var/pattern/pattern},${var//pattern/pattern}
		第一种模式：${var:num}，这种模式时，shell在var中提取第num个字符到末尾的所有字符。
			若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如${var: -2}、${var:1-3}或${var:(-2)}。         
		第二种模式：${var:num1:num2}，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。
		第三种模式：${var/pattern/pattern}表示将var字符串的第一个匹配的pattern替换为另一个pattern。。         
		第四种模式：${var//pattern/pattern}表示将var字符串中的所有能匹配的pattern替换为另一个pattern。
四、符号$后的括号
	（1）${a} 变量a的值, 在不引起歧义的情况下可以省略大括号。
	（2）$(cmd) 命令替换，和`cmd`效果相同，结果为shell命令cmd的输，过某些Shell版本不支持$()形式的命令替换, 如tcsh。
	（3）$((expression)) 和`exprexpression`效果相同, 计算数学表达式exp的数值, 其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。
五、多条命令执行
	（1）单小括号，(cmd1;cmd2;cmd3) 新开一个子shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后可以没有分号。
		括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。
	（2）单大括号，{ cmd1;cmd2;cmd3;} 在当前shell顺序执行命令cmd1,cmd2,cmd3, 各命令之间用分号隔开, 最后一个命令后必须有分号, 第一条命令和左括号之间必须用空格隔开。
		大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。

